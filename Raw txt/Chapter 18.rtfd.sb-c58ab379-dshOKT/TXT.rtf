{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Bold;\f1\froman\fcharset0 Times-Roman;\f2\fnil\fcharset0 AppleSymbols;
\f3\fswiss\fcharset0 Helvetica;\f4\froman\fcharset0 Times-Italic;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat2\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid4}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs56 \cf2 \expnd0\expndtw0\kerning0
Chapter 18 
\f1\b0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs66\fsmilli33333 \cf2 Inheritance 
\f1\b0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 In this chapter I present classes to represent playing cards, decks of cards, and poker hands. If you don\'92t play poker, you can read about it at http://en.wikipedia.org/wiki/Poker, but you don\'92t have to; I\'92ll tell you what you need to know for the exercises. Code examples from this chapter are available from http://thinkpython.com/code/Card.py. 
\fs24 \

\fs26\fsmilli13333 If you are not familiar with Anglo-American playing cards, you can read about them at http://en.wikipedia.org/wiki/Playing_cards. 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 18.1 Card objects 
\f1\b0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 There are fifty-two cards in a deck, each of which belongs to one of four suits and one of thirteen ranks. The suits are Spades, Hearts, Diamonds, and Clubs (in descending order in bridge). The ranks are Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, and King. Depending on the game that you are playing, an Ace may be higher than King or lower than 2. 
\fs24 \

\fs26\fsmilli13333 If we want to define a new object to represent a playing card, it is obvious what the at- tributes should be: rank and suit. It is not as obvious what type the attributes should be. One possibility is to use strings containing words like 'Spade' for suits and 'Queen' for ranks. One problem with this implementation is that it would not be easy to compare cards to see which had a higher rank or suit. 
\fs24 \

\fs26\fsmilli13333 An alternative is to use integers to 
\f0\b encode 
\f1\b0 the ranks and suits. In this context, \'93encode\'94 means that we are going to define a mapping between numbers and suits, or between numbers and ranks. This kind of encoding is not meant to be a secret (that would be \'93encryption\'94). 
\fs24 \

\fs26\fsmilli13333 For example, this table shows the suits and the corresponding integer codes: 
\fs24 \

\fs26\fsmilli13333 Spades 
\f2 \uc0\u56319 \u56320 \u8594 
\f1  3 Hearts 
\f2 \uc0\u56319 \u56320 \u8594 
\f1  2 Diamonds 
\f2 \uc0\u56319 \u56320 \u8594 
\f1  1 Clubs 
\f2 \uc0\u56319 \u56320 \u8594 
\f1  0 
\fs24 \

\fs26\fsmilli13333 This code makes it easy to compare cards; because higher suits map to higher numbers, we can compare suits by comparing their codes. 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs26\fsmilli13333 \cf2 168 Chapter18. Inheritance 
\f1\b0\fs24 \
\pard\pardeftab720\partightenfactor0
\cf2 {{\NeXTGraphic page190image63913344.png \width5005 \height12 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\pardeftab720\partightenfactor0
\cf2 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 The mapping for ranks is fairly obvious; each of the numerical ranks maps to the corre- sponding integer, and for face cards: 
\fs24 \

\fs26\fsmilli13333 Jack 
\f2 \uc0\u56319 \u56320 \u8594 
\f1  11 Queen 
\f2 \uc0\u56319 \u56320 \u8594 
\f1  12 King 
\f2 \uc0\u56319 \u56320 \u8594 
\f1  13 
\fs24 \

\fs26\fsmilli13333 I am using the 
\f2 \uc0\u56319 \u56320 \u8594 
\f1  symbol to make it clear that these mappings are not part of the Python program. They are part of the program design, but they don\'92t appear explicitly in the code. 
\fs24 \

\fs26\fsmilli13333 The class definition for Card looks like this: class Card(object): 
\fs24 \

\fs26\fsmilli13333 """Represents a standard playing card.""" 
\fs24 \

\fs26\fsmilli13333 def __init__(self, suit=0, rank=2): 
\fs24 \

\fs26\fsmilli13333 self.suit = suit 
\fs24 \

\fs26\fsmilli13333 self.rank = rank 
\fs24 \

\fs26\fsmilli13333 As usual, the init method takes an optional parameter for each attribute. The default card is the 2 of Clubs. 
\fs24 \

\fs26\fsmilli13333 To create a Card, you call Card with the suit and rank of the card you want. queen_of_diamonds = Card(1, 12) 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 18.2 Class attributes 
\f1\b0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 In order to print Card objects in a way that people can easily read, we need a mapping from the integer codes to the corresponding ranks and suits. A natural way to do that is with lists of strings. We assign these lists to 
\f0\b class attributes
\f1\b0 : 
\fs24 \

\fs26\fsmilli13333 # inside class Card: 
\fs24 \

\fs26\fsmilli13333 suit_names = ['Clubs', 'Diamonds', 'Hearts', 'Spades'] 
\fs24 \

\fs26\fsmilli13333 rank_names = [None, 'Ace', '2', '3', '4', '5', '6', '7', 
\fs24 \

\fs26\fsmilli13333 '8', '9', '10', 'Jack', 'Queen', 'King'] 
\fs24 \

\fs26\fsmilli13333 def __str__(self): 
\fs24 \

\fs26\fsmilli13333 return '%s of %s' % (Card.rank_names[self.rank], 
\fs24 \

\fs26\fsmilli13333 Card.suit_names[self.suit]) 
\fs24 \

\fs26\fsmilli13333 Variables like suit_names and rank_names, which are defined inside a class but outside of any method, are called class attributes because they are associated with the class object Card. 
\fs24 \

\fs26\fsmilli13333 This term distinguishes them from variables like suit and rank, which are called 
\f0\b instance attributes 
\f1\b0 because they are associated with a particular instance. 
\fs24 \

\fs26\fsmilli13333 Both kinds of attribute are accessed using dot notation. For example, in __str__, self is a Card object, and self.rank is its rank. Similarly, Card is a class object, and Card.rank_names is a list of strings associated with the class. 
\fs24 \

\fs26\fsmilli13333 Every card has its own suit and rank, but there is only one copy of suit_names and rank_names. 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs26\fsmilli13333 \cf2 18.3. Comparingcards 
\f1\b0\fs24 \

\f0\b\fs26\fsmilli13333 169 
\f1\b0\fs24 \
\pard\pardeftab720\partightenfactor0
\cf2 {{\NeXTGraphic page190image63913344.png \width5005 \height12 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\pardeftab720\partightenfactor0
\cf2  {{\NeXTGraphic page191image36000688.png \width1586 \height1090 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\
\pard\pardeftab720\sa240\partightenfactor0

\f3 \cf2 Card 
\f1 \

\f3 Card card1 
\f1 \

\f3 type 
\f1 \

\f3 list 
\f1 \

\f3 list 
\f1 \

\f3 suit_names 
\f1 \

\f3 rank_names 
\f1 \
\pard\pardeftab720\partightenfactor0
\cf2 {{\NeXTGraphic page191image35998896.png \width1306 \height653 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\pardeftab720\partightenfactor0
\cf2 \
\pard\pardeftab720\sa240\partightenfactor0

\f3 \cf2 suit 1 rank 11 
\f1 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 Figure 18.1: Object diagram. 
\fs24 \

\fs26\fsmilli13333 Putting it all together, the expression Card.rank_names[self.rank] means \'93use the at- tribute rank from the object self as an index into the list rank_names from the class Card, and select the appropriate string.\'94 
\fs24 \

\fs26\fsmilli13333 The first element of rank_names is None because there is no card with rank zero. By includ- ing None as a place-keeper, we get a mapping with the nice property that the index 2 maps to the string '2', and so on. To avoid this tweak, we could have used a dictionary instead of a list. 
\fs24 \

\fs26\fsmilli13333 With the methods we have so far, we can create and print cards: 
\fs24 \

\fs26\fsmilli13333 >>> card1 = Card(2, 11) 
\fs24 \

\fs26\fsmilli13333 >>> print card1 
\fs24 \

\fs26\fsmilli13333 Jack of Hearts 
\fs24 \

\fs26\fsmilli13333 Figure 18.1 is a diagram of the Card class object and one Card instance.\uc0\u8232 object, so it has type type. card1 has type Card. (To save space, I didn\'92t draw the contents of suit_names and rank_names). 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 18.3 Comparing cards 
\f1\b0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 For built-in types, there are relational operators (<, >, ==, etc.) that compare values and de- termine when one is greater than, less than, or equal to another. For user-defined types, we can override the behavior of the built-in operators by providing a method named __cmp__. 
\fs24 \

\fs26\fsmilli13333 __cmp__ takes two parameters, self and other, and returns a positive number if the first object is greater, a negative number if the second object is greater, and 0 if they are equal to each other. 
\fs24 \

\fs26\fsmilli13333 The correct ordering for cards is not obvious. For example, which is better, the 3 of Clubs or the 2 of Diamonds? One has a higher rank, but the other has a higher suit. In order to compare cards, you have to decide whether rank or suit is more important. 
\fs24 \

\fs26\fsmilli13333 The answer might depend on what game you are playing, but to keep things simple, we\'92ll make the arbitrary choice that suit is more important, so all of the Spades outrank all of the Diamonds, and so on. 
\fs24 \

\fs26\fsmilli13333 With that decided, we can write __cmp__: 
\fs24 \

\fs26\fsmilli13333 Card is a class 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs26\fsmilli13333 \cf2 170 Chapter18. Inheritance 
\f1\b0\fs24 \
\pard\pardeftab720\partightenfactor0
\cf2 {{\NeXTGraphic page190image63913344.png \width5005 \height12 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\pardeftab720\partightenfactor0
\cf2 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 # inside class Card: 
\fs24 \

\fs26\fsmilli13333 def __cmp__(self, other): 
\fs24 \

\fs26\fsmilli13333 # check the suits 
\fs24 \

\fs26\fsmilli13333 if self.suit > other.suit: return 1 
\fs24 \

\fs26\fsmilli13333 if self.suit < other.suit: return -1 
\fs24 \

\fs26\fsmilli13333 # suits are the same... check ranks 
\fs24 \

\fs26\fsmilli13333 if self.rank > other.rank: return 1 
\fs24 \

\fs26\fsmilli13333 if self.rank < other.rank: return -1 
\fs24 \

\fs26\fsmilli13333 # ranks are the same... it's a tie 
\fs24 \

\fs26\fsmilli13333 return 0 
\fs24 \

\fs26\fsmilli13333 You can write this more concisely using tuple comparison: 
\fs24 \

\fs26\fsmilli13333 # inside class Card: 
\fs24 \

\fs26\fsmilli13333 def __cmp__(self, other): 
\fs24 \

\fs26\fsmilli13333 t1 = self.suit, self.rank 
\fs24 \

\fs26\fsmilli13333 t2 = other.suit, other.rank 
\fs24 \

\fs26\fsmilli13333 return cmp(t1, t2) 
\fs24 \

\fs26\fsmilli13333 The built-in function cmp has the same interface as the method __cmp__: it takes two values and returns a positive number if the first is larger, a negative number if the second is larger, and 0 if they are equal. 
\fs24 \

\fs26\fsmilli13333 In Python 3, cmp no longer exists, and the __cmp__ method is not supported. Instead you should provide __lt__, which returns True if self is less than other. You can implement __lt__ using tuples and the < operator.\uc0\u8232 
\f0\b Exercise 18.1. 
\f4\i\b0 Write a 
\f1\i0 __cmp__ 
\f4\i method for Time objects. Hint: you can use tuple comparison, but you also might consider using integer subtraction. 
\f1\i0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 18.4 Decks 
\f1\b0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 Now that we have Cards, the next step is to define Decks. Since a deck is made up of cards, it is natural for each Deck to contain a list of cards as an attribute. 
\fs24 \

\fs26\fsmilli13333 The following is a class definition for Deck. The init method creates the attribute cards and generates the standard set of fifty-two cards: 
\fs24 \

\fs26\fsmilli13333 class Deck(object): 
\fs24 \

\fs26\fsmilli13333 def __init__(self): 
\fs24 \

\fs26\fsmilli13333 self.cards = [] 
\fs24 \

\fs26\fsmilli13333 for suit in range(4): 
\fs24 \

\fs26\fsmilli13333 for rank in range(1, 14): 
\fs24 \

\fs26\fsmilli13333 card = Card(suit, rank) 
\fs24 \

\fs26\fsmilli13333 self.cards.append(card) 
\fs24 \

\fs26\fsmilli13333 The easiest way to populate the deck is with a nested loop. The outer loop enumerates the suits from 0 to 3. The inner loop enumerates the ranks from 1 to 13. Each iteration creates a new Card with the current suit and rank, and appends it to self.cards. 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs26\fsmilli13333 \cf2 18.5. Printingthedeck 171 
\fs37\fsmilli18667 18.5 Printing the deck 
\f1\b0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 Here is a __str__ method for Deck: #inside class Deck: 
\fs24 \

\fs26\fsmilli13333 def __str__(self): 
\fs24 \

\fs26\fsmilli13333 res = [] 
\fs24 \

\fs26\fsmilli13333 for card in self.cards: 
\fs24 \

\fs26\fsmilli13333 res.append(str(card)) 
\fs24 \

\fs26\fsmilli13333 return '\\n'.join(res) 
\fs24 \

\fs26\fsmilli13333 This method demonstrates an efficient way to accumulate a large string: building a list of strings and then using join. The built-in function str invokes the __str__ method on each card and returns the string representation. 
\fs24 \

\fs26\fsmilli13333 Since we invoke join on a newline character, the cards are separated by newlines. Here\'92s what the result looks like: 
\fs24 \

\fs26\fsmilli13333 >>> deck = Deck() 
\fs24 \

\fs26\fsmilli13333 >>> print deck 
\fs24 \

\fs26\fsmilli13333 Ace of Clubs 
\fs24 \

\fs26\fsmilli13333 2 of Clubs 
\fs24 \

\fs26\fsmilli13333 3 of Clubs 
\fs24 \

\fs26\fsmilli13333 ... 
\fs24 \

\fs26\fsmilli13333 10 of Spades 
\fs24 \

\fs26\fsmilli13333 Jack of Spades 
\fs24 \

\fs26\fsmilli13333 Queen of Spades 
\fs24 \

\fs26\fsmilli13333 King of Spades 
\fs24 \

\fs26\fsmilli13333 Even though the result appears on 52 lines, it is one long string that contains newlines. 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 18.6 Add, remove, shuffle and sort 
\f1\b0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 To deal cards, we would like a method that removes a card from the deck and returns it. The list method pop provides a convenient way to do that: 
\fs24 \

\fs26\fsmilli13333 #inside class Deck: 
\fs24 \

\fs26\fsmilli13333 def pop_card(self): 
\fs24 \

\fs26\fsmilli13333 return self.cards.pop() 
\fs24 \

\fs26\fsmilli13333 Since pop removes the 
\f4\i last 
\f1\i0 card in the list, we are dealing from the bottom of the deck. In real life \'93bottom dealing\'94 is frowned upon, but in this context it\'92s ok. 
\fs24 \

\fs26\fsmilli13333 To add a card, we can use the list method append: #inside class Deck: 
\fs24 \

\fs26\fsmilli13333 def add_card(self, card): 
\fs24 \

\fs26\fsmilli13333 self.cards.append(card) 
\fs24 \

\fs26\fsmilli13333 A method like this that uses another function without doing much real work is sometimes called a 
\f0\b veneer
\f1\b0 . The metaphor comes from woodworking, where it is common to glue a thin layer of good quality wood to the surface of a cheaper piece of wood. 
\fs24 \
\pard\pardeftab720\partightenfactor0
\cf2 {{\NeXTGraphic page190image63913344.png \width5005 \height12 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\pardeftab720\partightenfactor0
\cf2  \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs26\fsmilli13333 \cf2 172 Chapter18. Inheritance 
\f1\b0\fs24 \
\pard\pardeftab720\partightenfactor0
\cf2 {{\NeXTGraphic page190image63913344.png \width5005 \height12 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\pardeftab720\partightenfactor0
\cf2 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 In this case we are defining a \'93thin\'94 method that expresses a list operation in terms that are appropriate for decks. 
\fs24 \

\fs26\fsmilli13333 As another example, we can write a Deck method named shuffle using the function shuffle from the random module: 
\fs24 \

\fs26\fsmilli13333 # inside class Deck: 
\fs24 \

\fs26\fsmilli13333 def shuffle(self): 
\fs24 \

\fs26\fsmilli13333 random.shuffle(self.cards) 
\fs24 \

\fs26\fsmilli13333 Don\'92t forget to import random.\uc0\u8232 
\f0\b Exercise 18.2. 
\f4\i\b0 Write a Deck method named 
\f1\i0 sort 
\f4\i that uses the list method 
\f1\i0 sort 
\f4\i to sort the cards in a 
\f1\i0 Deck
\f4\i . 
\f1\i0 sort 
\f4\i uses the 
\f1\i0 __cmp__ 
\f4\i method we defined to determine sort order. 
\f1\i0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 18.7 Inheritance 
\f1\b0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 The language feature most often associated with object-oriented programming is 
\f0\b inher- itance
\f1\b0 . Inheritance is the ability to define a new class that is a modified version of an existing class. 
\fs24 \

\fs26\fsmilli13333 It is called \'93inheritance\'94 because the new class inherits the methods of the existing class. Extending this metaphor, the existing class is called the 
\f0\b parent 
\f1\b0 and the new class is called the 
\f0\b child
\f1\b0 . 
\fs24 \

\fs26\fsmilli13333 As an example, let\'92s say we want a class to represent a \'93hand,\'94 that is, the set of cards held by one player. A hand is similar to a deck: both are made up of a set of cards, and both require operations like adding and removing cards. 
\fs24 \

\fs26\fsmilli13333 A hand is also different from a deck; there are operations we want for hands that don\'92t make sense for a deck. For example, in poker we might compare two hands to see which one wins. In bridge, we might compute a score for a hand in order to make a bid. 
\fs24 \

\fs26\fsmilli13333 This relationship between classes\'97similar, but different\'97lends itself to inheritance. 
\fs24 \

\fs26\fsmilli13333 The definition of a child class is like other class definitions, but the name of the parent class appears in parentheses: 
\fs24 \

\fs26\fsmilli13333 class Hand(Deck): 
\fs24 \

\fs26\fsmilli13333 """Represents a hand of playing cards.""" 
\fs24 \

\fs26\fsmilli13333 This definition indicates that Hand inherits from Deck; that means we can use methods like pop_card and add_card for Hands as well as Decks. 
\fs24 \

\fs26\fsmilli13333 Hand also inherits __init__ from Deck, but it doesn\'92t really do what we want: instead of populating the hand with 52 new cards, the init method for Hands should initialize cards with an empty list. 
\fs24 \

\fs26\fsmilli13333 If we provide an init method in the Hand class, it overrides the one in the Deck class: # inside class Hand: 
\fs24 \

\fs26\fsmilli13333 def __init__(self, label=''): 
\fs24 \

\fs26\fsmilli13333 self.cards = [] 
\fs24 \

\fs26\fsmilli13333 self.label = label 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs26\fsmilli13333 \cf2 18.8. Classdiagrams 173 
\f1\b0\fs24 \
\pard\pardeftab720\partightenfactor0
\cf2 {{\NeXTGraphic page190image63913344.png \width5005 \height12 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\pardeftab720\partightenfactor0
\cf2 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 So when you create a Hand, Python invokes this init method: 
\fs24 \

\fs26\fsmilli13333 >>> hand = Hand('new hand') 
\fs24 \

\fs26\fsmilli13333 >>> print hand.cards 
\fs24 \

\fs26\fsmilli13333 [] 
\fs24 \

\fs26\fsmilli13333 >>> print hand.label 
\fs24 \

\fs26\fsmilli13333 new hand 
\fs24 \

\fs26\fsmilli13333 But the other methods are inherited from Deck, so we can use pop_card and add_card to deal a card: 
\fs24 \

\fs26\fsmilli13333 >>> deck = Deck() 
\fs24 \

\fs26\fsmilli13333 >>> card = deck.pop_card() 
\fs24 \

\fs26\fsmilli13333 >>> hand.add_card(card) 
\fs24 \

\fs26\fsmilli13333 >>> print hand 
\fs24 \

\fs26\fsmilli13333 King of Spades 
\fs24 \

\fs26\fsmilli13333 A natural next step is to encapsulate this code in a method called move_cards: #inside class Deck: 
\fs24 \

\fs26\fsmilli13333 def move_cards(self, hand, num): 
\fs24 \

\fs26\fsmilli13333 for i in range(num): 
\fs24 \

\fs26\fsmilli13333 hand.add_card(self.pop_card()) 
\fs24 \

\fs26\fsmilli13333 move_cards takes two arguments, a Hand object and the number of cards to deal. It modi- fies both self and hand, and returns None. 
\fs24 \

\fs26\fsmilli13333 In some games, cards are moved from one hand to another, or from a hand back to the deck. You can use move_cards for any of these operations: self can be either a Deck or a Hand, and hand, despite the name, can also be a Deck.\uc0\u8232 
\f0\b Exercise 18.3. 
\f4\i\b0 Write a Deck method called 
\f1\i0 deal_hands 
\f4\i that takes two parameters, the number of hands and the number of cards per hand, and that creates new Hand objects, deals the appropriate number of cards per hand, and returns a list of Hand objects. 
\f1\i0\fs24 \

\fs26\fsmilli13333 Inheritance is a useful feature. Some programs that would be repetitive without inheritance can be written more elegantly with it. Inheritance can facilitate code reuse, since you can customize the behavior of parent classes without having to modify them. In some cases, the inheritance structure reflects the natural structure of the problem, which makes the program easier to understand. 
\fs24 \

\fs26\fsmilli13333 On the other hand, inheritance can make programs difficult to read. When a method is invoked, it is sometimes not clear where to find its definition. The relevant code may be scattered among several modules. Also, many of the things that can be done using inheritance can be done as well or better without it. 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 18.8 Class diagrams 
\f1\b0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 So far we have seen stack diagrams, which show the state of a program, and object dia- grams, which show the attributes of an object and their values. These diagrams represent a snapshot in the execution of a program, so they change as the program runs. 
\fs24 \

\fs26\fsmilli13333 They are also highly detailed; for some purposes, too detailed. A class diagram is a more abstract representation of the structure of a program. Instead of showing individual ob- jects, it shows classes and the relationships between them. 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs26\fsmilli13333 \cf2 174 
\f1\b0\fs24 \

\f0\b\fs26\fsmilli13333 Chapter18. Inheritance 
\f1\b0\fs24 \
\pard\pardeftab720\partightenfactor0
\cf2 {{\NeXTGraphic page190image63913344.png \width5005 \height12 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\pardeftab720\partightenfactor0
\cf2  {{\NeXTGraphic page196image35751232.png \width874 \height437 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬} {{\NeXTGraphic page196image35751232.png \width874 \height437 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\
\pard\pardeftab720\sa240\partightenfactor0

\f3\fs29\fsmilli14667 \cf2 * 
\f1\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 Figure 18.2: Class diagram. 
\fs24 \

\fs26\fsmilli13333 There are several kinds of relationship between classes: 
\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa266\partightenfactor0
\ls1\ilvl0
\fs26\fsmilli13333 \cf2 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Objects in one class might contain references to objects in another class. For example, each Rectangle contains a reference to a Point, and each Deck contains references to many Cards. This kind of relationship is called 
\f0\b HAS-A
\f1\b0 , as in, \'93a Rectangle has a Point.\'94 \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
One class might inherit from another. This relationship is called 
\f0\b IS-A
\f1\b0 , as in, \'93a Hand is a kind of a Deck.\'94 \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
One class might depend on another in the sense that changes in one class would require changes in the other. \uc0\u8232 A 
\f0\b class diagram 
\f1\b0 is a graphical representation of these relationships. For example, Fig- ure 18.2 shows the relationships between Card, Deck and Hand. \uc0\u8232 The arrow with a hollow triangle head represents an IS-A relationship; in this case it indi- cates that Hand inherits from Deck. \u8232 The standard arrow head represents a HAS-A relationship; in this case a Deck has refer- ences to Card objects. \u8232 The star (*) near the arrow head is a 
\f0\b multiplicity
\f1\b0 ; it indicates how many Cards a Deck has. A multiplicity can be a simple number, like 52, a range, like 5..7 or a star, which indicates that a Deck can have any number of Cards. \uc0\u8232 A more detailed diagram might show that a Deck actually contains a 
\f4\i list 
\f1\i0 of Cards, but built-in types like list and dict are usually not included in class diagrams.\uc0\u8232 
\f0\b Exercise 18.4. 
\f4\i\b0 Read 
\f1\i0 TurtleWorld.py
\f4\i , 
\f1\i0 World.py 
\f4\i and 
\f1\i0 Gui.py 
\f4\i and draw a class diagram that shows the relationships among the classes defined there. 
\f1\i0 \uc0\u8232 
\f0\b\fs37\fsmilli18667 18.9 Debugging 
\f1\b0\fs26\fsmilli13333 \uc0\u8232 Inheritance can make debugging a challenge because when you invoke a method on an object, you might not know which method will be invoked. \u8232 Suppose you are writing a function that works with Hand objects. You would like it to work with all kinds of Hands, like PokerHands, BridgeHands, etc. If you invoke a method like shuffle, you might get the one defined in Deck, but if any of the subclasses override this method, you\'92ll get that version instead. \u8232 Any time you are unsure about the flow of execution through your program, the sim- plest solution is to add print statements at the beginning of the relevant methods. If \u8232 \
\pard\pardeftab720\sa240\partightenfactor0

\f3\fs24 \cf2 Deck 
\f1 \
\pard\pardeftab720\partightenfactor0
\cf2 {{\NeXTGraphic page196image63903936.png \width390 \height11 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\pardeftab720\partightenfactor0
\cf2 \
\pard\pardeftab720\sa240\partightenfactor0

\f3 \cf2 Hand 
\f1 \

\f3 Card 
\f1 \
\pard\pardeftab720\partightenfactor0
\cf2 {{\NeXTGraphic page196image35751232.png \width874 \height437 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\pardeftab720\partightenfactor0
\cf2  \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs26\fsmilli13333 \cf2 18.10. Dataencapsulation 175 
\f1\b0\fs24 \
\pard\pardeftab720\partightenfactor0
\cf2 {{\NeXTGraphic page190image63913344.png \width5005 \height12 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\pardeftab720\partightenfactor0
\cf2 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 Deck.shuffle prints a message that says something like Running Deck.shuffle, then as the program runs it traces the flow of execution. 
\fs24 \

\fs26\fsmilli13333 As an alternative, you could use this function, which takes an object and a method name (as a string) and returns the class that provides the definition of the method: 
\fs24 \

\fs26\fsmilli13333 def find_defining_class(obj, meth_name): 
\fs24 \

\fs26\fsmilli13333 for ty in type(obj).mro(): 
\fs24 \

\fs26\fsmilli13333 if meth_name in ty.__dict__: 
\fs24 \

\fs26\fsmilli13333 return ty 
\fs24 \

\fs26\fsmilli13333 Here\'92s an example: 
\fs24 \

\fs26\fsmilli13333 >>> hand = Hand() 
\fs24 \

\fs26\fsmilli13333 >>> print find_defining_class(hand, 'shuffle') 
\fs24 \

\fs26\fsmilli13333 <class 'Card.Deck'> 
\fs24 \

\fs26\fsmilli13333 So the shuffle method for this Hand is the one in Deck.\uc0\u8232 find_defining_class uses the mro method to get the list of class objects (types) that will 
\fs24 \

\fs26\fsmilli13333 be searched for methods. \'93MRO\'94 stands for \'93method resolution order.\'94 
\fs24 \

\fs26\fsmilli13333 Here\'92s a program design suggestion: whenever you override a method, the interface of the new method should be the same as the old. It should take the same parameters, return the same type, and obey the same preconditions and postconditions. If you obey this rule, you will find that any function designed to work with an instance of a superclass, like a Deck, will also work with instances of subclasses like a Hand or PokerHand. 
\fs24 \

\fs26\fsmilli13333 If you violate this rule, your code will collapse like (sorry) a house of cards. 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 18.10 Data encapsulation 
\f1\b0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 Chapter 16 demonstrates a development plan we might call \'93object-oriented design.\'94 We identified objects we needed\'97Time, Point and Rectangle\'97and defined classes to repre- sent them. In each case there is an obvious correspondence between the object and some entity in the real world (or at least a mathematical world). 
\fs24 \

\fs26\fsmilli13333 But sometimes it is less obvious what objects you need and how they should interact. In that case you need a different development plan. In the same way that we discovered function interfaces by encapsulation and generalization, we can discover class interfaces by 
\f0\b data encapsulation
\f1\b0 . 
\fs24 \

\fs26\fsmilli13333 Markov analysis, from Section 13.8, provides a good example. If you download my code from http://thinkpython.com/code/markov.py, you\'92ll see that it uses two global variables\'97suffix_map and prefix\'97that are read and written from several functions. 
\fs24 \

\fs26\fsmilli13333 suffix_map = \{\} 
\fs24 \

\fs26\fsmilli13333 prefix = () 
\fs24 \

\fs26\fsmilli13333 Because these variables are global we can only run one analysis at a time. If we read two texts, their prefixes and suffixes would be added to the same data structures (which makes for some interesting generated text). 
\fs24 \

\fs26\fsmilli13333 To run multiple analyses, and keep them separate, we can encapsulate the state of each analysis in an object. Here\'92s what that looks like: 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs26\fsmilli13333 \cf2 176 Chapter18. Inheritance 
\f1\b0\fs24 \
\pard\pardeftab720\partightenfactor0
\cf2 {{\NeXTGraphic page190image63913344.png \width5005 \height12 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\pardeftab720\partightenfactor0
\cf2 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 class Markov(object): 
\fs24 \

\fs26\fsmilli13333 def __init__(self): 
\fs24 \

\fs26\fsmilli13333 self.suffix_map = \{\} 
\fs24 \

\fs26\fsmilli13333 self.prefix = () 
\fs24 \

\fs26\fsmilli13333 Next, we transform the functions into methods. For example, here\'92s process_word: def process_word(self, word, order=2): 
\fs24 \

\fs26\fsmilli13333 if len(self.prefix) < order: 
\fs24 \

\fs26\fsmilli13333 try: 
\fs24 \

\fs26\fsmilli13333 self.prefix += (word,) 
\fs24 \

\fs26\fsmilli13333 return 
\fs24 \

\fs26\fsmilli13333 self.suffix_map[self.prefix].append(word) 
\fs24 \

\fs26\fsmilli13333 except KeyError: 
\fs24 \

\fs26\fsmilli13333 # if there is no entry for this prefix, make one 
\fs24 \

\fs26\fsmilli13333 self.suffix_map[self.prefix] = [word] 
\fs24 \

\fs26\fsmilli13333 self.prefix = shift(self.prefix, word) 
\fs24 \

\fs26\fsmilli13333 Transforming a program like this\'97changing the design without changing the function\'97is another example of refactoring (see Section 4.7). 
\fs24 \

\fs26\fsmilli13333 This example suggests a development plan for designing objects and methods: 
\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa266\partightenfactor0
\ls2\ilvl0
\fs26\fsmilli13333 \cf2 \kerning1\expnd0\expndtw0 {\listtext	1.	}\expnd0\expndtw0\kerning0
Start by writing functions that read and write global variables (when necessary). \uc0\u8232 \
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	2.	}\expnd0\expndtw0\kerning0
Once you get the program working, look for associations between global variables and the functions that use them. \uc0\u8232 \
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	3.	}\expnd0\expndtw0\kerning0
Encapsulate related variables as attributes of an object. \uc0\u8232 \
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	4.	}\expnd0\expndtw0\kerning0
Transform the associated functions into methods of the new class. \uc0\u8232 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b \cf2 Exercise 18.5. 
\f4\i\b0 Download my code from Section 13.8 (
\f1\i0 http://thinkpython.com/code/ markov. py 
\f4\i ), and follow the steps described above to encapsulate the global variables as attributes of a new class called 
\f1\i0 Markov
\f4\i . Solution: 
\f1\i0 http: // thinkpython. com/ code/ Markov. py 
\f4\i (note the capital M). 
\f1\i0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 18.11 Glossary\uc0\u8232 
\fs26\fsmilli13333 encode: 
\f1\b0 To represent one set of values using another set of values by constructing a map- 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 ping between them. 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs26\fsmilli13333 \cf2 class attribute: 
\f1\b0 An attribute associated with a class object. Class attributes are defined inside a class definition but outside any method. 
\fs24 \

\f0\b\fs26\fsmilli13333 instance attribute: 
\f1\b0 An attribute associated with an instance of a class.\uc0\u8232 
\f0\b veneer: 
\f1\b0 A method or function that provides a different interface to another function with- 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 out doing much computation. 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs26\fsmilli13333 \cf2 inheritance: 
\f1\b0 The ability to define a new class that is a modified version of a previously defined class. 
\fs24 \

\f0\b\fs26\fsmilli13333 18.12. Exercises 177 parent class: 
\f1\b0 The class from which a child class inherits. 
\fs24 \

\f0\b\fs26\fsmilli13333 child class: 
\f1\b0 A new class created by inheriting from an existing class; also called a \'93sub- class.\'94 
\fs24 \

\f0\b\fs26\fsmilli13333 IS-A relationship: 
\f1\b0 The relationship between a child class and its parent class.\uc0\u8232 
\f0\b HAS-A relationship: 
\f1\b0 The relationship between two classes where instances of one class 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 contain references to instances of the other. 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs26\fsmilli13333 \cf2 class diagram: 
\f1\b0 A diagram that shows the classes in a program and the relationships be- tween them. 
\fs24 \

\f0\b\fs26\fsmilli13333 multiplicity: 
\f1\b0 A notation in a class diagram that shows, for a HAS-A relationship, how many references there are to instances of another class. 
\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 18.12 Exercises\uc0\u8232 
\fs26\fsmilli13333 Exercise 18.6. 
\f4\i\b0 The following are the possible hands in poker, in increasing order of value (and 
\f1\i0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f4\i\fs26\fsmilli13333 \cf2 decreasing order of probability): 
\f1\i0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs26\fsmilli13333 \cf2 pair: 
\f4\i\b0 two cards with the same rank 
\f1\i0\fs24 \

\f0\b\fs26\fsmilli13333 two pair: 
\f4\i\b0 two pairs of cards with the same rank 
\f1\i0\fs24 \

\f0\b\fs26\fsmilli13333 three of a kind: 
\f4\i\b0 three cards with the same rank 
\f1\i0\fs24 \

\f0\b\fs26\fsmilli13333 straight: 
\f4\i\b0 five cards with ranks in sequence (aces can be high or low, so 
\f1\i0 Ace-2-3-4-5 
\f4\i is a straight and so is 
\f1\i0 10-Jack-Queen-King-Ace
\f4\i , but 
\f1\i0 Queen-King-Ace-2-3 
\f4\i is not.) 
\f1\i0\fs24 \

\f0\b\fs26\fsmilli13333 flush: 
\f4\i\b0 five cards with the same suit\uc0\u8232 
\f0\i0\b full house: 
\f4\i\b0 three cards with one rank, two cards with another\uc0\u8232 
\f0\i0\b four of a kind: 
\f4\i\b0 four cards with the same rank\uc0\u8232 
\f0\i0\b straight flush: 
\f4\i\b0 five cards in sequence (as defined above) and with the same suit 
\f1\i0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\f4\i\fs26\fsmilli13333 \cf2 The goal of these exercises is to estimate the probability of drawing these various hands. 
\f1\i0\fs24 \

\f4\i\fs26\fsmilli13333 1. Downloadthefollowingfilesfrom
\f1\i0 http://thinkpython.com/code
\f4\i : 
\f1\i0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0

\fs26\fsmilli13333 \cf2 Card.py 
\f4\i : A complete version of the 
\f1\i0 Card
\f4\i , 
\f1\i0 Deck 
\f4\i and 
\f1\i0 Hand 
\f4\i classes in this chapter. 
\f1\i0\fs24 \

\fs26\fsmilli13333 PokerHand.py 
\f4\i : An incomplete implementation of a class that represents a poker hand, and some code that tests it. 
\f1\i0\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa266\partightenfactor0
\ls3\ilvl0
\f4\i\fs26\fsmilli13333 \cf2 \kerning1\expnd0\expndtw0 {\listtext	2.	}\expnd0\expndtw0\kerning0
If you run PokerHand.py, it deals seven 7-card poker hands and checks to see if any of them contains a flush. Read this code carefully before you go on. \uc0\u8232 \
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	3.	}\expnd0\expndtw0\kerning0
Add methods to PokerHand.py named has_pair, has_twopair, etc. that return True or False according to whether or not the hand meets the relevant criteria. Your code should work correctly for \'93hands\'94 that contain any number of cards (although 5 and 7 are the most common sizes). \uc0\u8232 \
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	4.	}\expnd0\expndtw0\kerning0
Write a method named classify that figures out the highest-value classification for a hand and sets the label attribute accordingly. For example, a 7-card hand might contain a flush and a pair; it should be labeled \'93flush\'94. \uc0\u8232 \
\pard\pardeftab720\partightenfactor0

\f1\i0\fs24 \cf2 {{\NeXTGraphic page190image63913344.png \width5005 \height12 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\pardeftab720\partightenfactor0
\cf2  \
\pard\pardeftab720\sa240\partightenfactor0

\f0\b\fs26\fsmilli13333 \cf2 178 
\f1\b0\fs24 \

\f0\b\fs26\fsmilli13333 Chapter18. Inheritance 
\f1\b0\fs24 \
\pard\pardeftab720\partightenfactor0
\cf2 {{\NeXTGraphic page190image63913344.png \width5005 \height12 \appleattachmentpadding0 \appleembedtype0 \appleaqc
}¬}\pard\pardeftab720\partightenfactor0
\cf2 \
\pard\pardeftab720\sa240\partightenfactor0

\f4\i\fs26\fsmilli13333 \cf2 5. 
\f1\i0\fs24 \

\f4\i\fs26\fsmilli13333 6. 
\f1\i0\fs24 \

\f4\i\fs26\fsmilli13333 When you are convinced that your classification methods are working, the next step is to esti- mate the probabilities of the various hands. Write a function in 
\f1\i0 PokerHand.py 
\f4\i that shuffles a deck of cards, divides it into hands, classifies the hands, and counts the number of times various classifications appear. 
\f1\i0\fs24 \

\f4\i\fs26\fsmilli13333 Print a table of the classifications and their probabilities. Run your program with larger and larger numbers of hands until the output values converge to a reasonable degree of accu- racy. Compare your results to the values at 
\f1\i0 http: // en. wikipedia. org/ wiki/ Hand_ rankings 
\f4\i . 
\f1\i0\fs24 \

\f4\i\fs26\fsmilli13333 Solution: 
\f1\i0 http: // thinkpython. com/ code/ PokerHandSoln. py 
\f4\i .\uc0\u8232 
\f0\i0\b Exercise 18.7. 
\f4\i\b0 This exercise uses TurtleWorld from Chapter 4. You will write code that makes Turtles play tag. If you are not familiar with the rules of tag, see 
\f1\i0 http: // en. wikipedia. org/ wiki/ Tag_ ( game) 
\f4\i . 
\f1\i0\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa266\partightenfactor0
\ls4\ilvl0
\f4\i\fs26\fsmilli13333 \cf2 \kerning1\expnd0\expndtw0 {\listtext	1.	}\expnd0\expndtw0\kerning0
Download http: // thinkpython. com/ code/ Wobbler. py and run it. You should see a TurtleWorld with three Turtles. If you press the Run button, the Turtles wander at random. \uc0\u8232 \
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	2.	}\expnd0\expndtw0\kerning0
Read the code and make sure you understand how it works. The Wobbler class inherits from Turtle, which means that the Turtle methods lt, rt, fd and bk work on Wobblers. \uc0\u8232 The step method gets invoked by TurtleWorld. It invokes steer, which turns the Turtle in the desired direction, wobble, which makes a random turn in proportion to the Turtle\'92s clumsiness, and move, which moves forward a few pixels, depending on the Turtle\'92s speed. \u8232 \
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	3.	}\expnd0\expndtw0\kerning0
Create a file named Tagger.py. Import everything from Wobbler, then define a class named Tagger that inherits from Wobbler. Call make_world passing the Tagger class object as an argument. \uc0\u8232 \
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	4.	}\expnd0\expndtw0\kerning0
Add a steer method to Tagger to override the one in Wobbler. As a starting place, write a version that always points the Turtle toward the origin. Hint: use the math function atan2 and the Turtle attributes x, y and heading. \uc0\u8232 \
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	5.	}\expnd0\expndtw0\kerning0
Modify steer so that the Turtles stay in bounds. For debugging, you might want to use the Step button, which invokes step once on each Turtle. \uc0\u8232 \
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	6.	}\expnd0\expndtw0\kerning0
Modify steer so that each Turtle points toward its nearest neighbor. Hint: Turtles have an attribute, world, that is a reference to the TurtleWorld they live in, and the TurtleWorld has an attribute, animals, that is a list of all Turtles in the world. \uc0\u8232 \
\ls4\ilvl0\kerning1\expnd0\expndtw0 {\listtext	7.	}\expnd0\expndtw0\kerning0
Modify steer so the Turtles play tag. You can add methods to Tagger and you can override steer and __init__, but you may not modify or override step, wobble or move. Also, steer is allowed to change the heading of the Turtle but not the position. \uc0\u8232 Adjust the rules and your steer method for good quality play; for example, it should be possible for the slow Turtle to tag the faster Turtles eventually. \u8232 \
\pard\pardeftab720\sa240\partightenfactor0
\cf2 Solution: 
\f1\i0 http: // thinkpython. com/ code/ Tagger. py 
\f4\i . 
\f1\i0\fs24 \
///////////////}